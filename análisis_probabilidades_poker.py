# -*- coding: utf-8 -*-
"""An√°lisis Probabilidades Poker.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1THKnZsYU4vKhPed0E2k-cIOOpcTzT6kw

probabilities analysis
"""

import random

class carta:
  nombre_palo=["Treboles", "Diamantes", "Corazon", "Espadas"]
  nombre_rango=[None, "AS", "2", "3", "4", "5", "6", "7","8", "9", "10", "Jota", "Reina", "Rey"] 
              
  """ atributos palo y rango """ 
  def __init__(self, palo=0, rango=2):
    self.palo=palo
    self.rango=rango

  def __str__(self):
    return '%s de %s' % (carta.nombre_rango[self.rango],carta.nombre_palo[self.palo]) 

  def __eq__(self,otra):
    return self.palo==otra.palo and self.rango==otra.rango   

  def __lt__(self,otra):
    """  se compara como tuplas   """
    t1=self.palo, self.rango
    t2=otra.palo, otra.rango
    return t1<t2

class baraja:
  """ atributos cartas """ 
  def __init__(self):
    self.cartas= []
    for palo in range(4):
      for rango in range(14):
        cartai=carta(palo,rango)
        self.cartas.append(cartai)

  def __str__(self):
    res=[]
    for carta in self.cartas:
      res.append(str(carta))
    return '\n'.join(res)    

  def quitar_carta(self):
    return self.cartas.pop()

  def agregar_cartas(self,carta):
    self.cartas.append(carta)

  def barajar(self):
    random.shuffle(self.cartas)

  def ordenar(self):
    self.cartas.sort()    

  def repartir_manos(self,numero_mano,numero_carta):
    manos=[]
    for m in range(numero_mano):
      manoi=mano(str(m))
      for c in range(numero_carta):
        manoi.agregar_cartas(self.quitar_carta())
      manos.append(manoi)
    return manos   

  def mover_cartas(self,mano,numero):
    for i in range(numero):
      mano.agregar_cartas(self.quitar_carta())

class mano (baraja):
  """ representa una mano de cartas """
  def __init__(self, etiqueta=' '):
    self.cartas=[]
    self.etiqueta=etiqueta

def imprimir_lista(listamanos,numero):
  i=1
  for ma in listamanos:
    print (ma)
    i+=1
    if i>numero:
      break

class Pokermano(mano):
  """ representa una mano de Poker """
  
  nombre_clasificacion=["pareja", "doble_pareja", "trio", "escalera", "color", "full", "poker","escalera_real"]

  def crear_histo(self):
    self.histo= {}
    self.histor= {}
    for cartam in self.cartas:
      self.histo[cartam.palo]=self.histo.get(cartam.palo, 0) + 1     
    for cartar in self.cartas:
      self.histor[cartar.rango]=self.histor.get(cartar.rango, 0) + 1
    self.sets = list(self.histor.values())  
    self.sets.sort(reverse=True)
    """print(self.sets) 
    print(self.histor.keys())
    print(self.histor.values())
    print(self.histo.keys())
    print(self.histo.values())"""

  def check_sets(self,*t):
        
    """ chequea que la lista self.sts tenga el minimo requerido para cualquier clasifcacion """
    for necesita,tiene in zip (t,self.sets):
      if necesita > tiene:
        return False
    return True 
    
  def tiene_color(self):
    for valor in self.histo.values():
      if valor >= 5:
        return True
      """else:
        print(self.histo.values())"""
    return False

  def tiene_pareja(self):
    if self.sets.count(2) >= 1:
      return True
      """else:
        print(self.histor.values())"""
    return False


  def tiene_doble_pareja(self):
    """ debere evaluar si hay 2 values igual a 2 """
    if self.sets.count(2) >=2:
      return True
      """else:
        print(self.histor.values())"""
    return False

  def tiene_trio(self):
    if self.sets.count(3) >=1:
      return True
      """else:
        print(self.histor.values())"""
    return False

  def tiene_poker(self):
    """print('poker')"""
    if self.sets.count(4) >=1:
      return True
      """else:
        print(self.histor.values())"""
    return False       

  def tiene_full(self):
    if (self.tiene_pareja() and self.tiene_trio()):
      print('Tiene Full House')  
      return True
    return False   

  def tiene_escalera(self):
    """ Se hace copia del histrograma de rangos, que tiene los rangos (numero de la carta) como keys
        Se agregar al final del historial nuevo el As, por que puede estar en los extremos para las escaleras  
    """ 
    rangos=self.histor.copy()
    rangos[14]=rangos.get(1,0)
    return self.tiene_consecutivos(rangos,5)

  def tiene_consecutivos(self,rangos,y=5):
    """ Se hace un recurrrido secuencial para comparar contra los valores en el histrograma
    y evaluar si hay alguna secuencia de 5 numeros
    """
    for h in range (1,15):
      contador=0
      if rangos.get(h,0):
        contador +=1
        if contador == y:
          return True
      else:
        contador=0
    return False   

  def tiene_escalera_real(self):
     """ se construye un diccionario, la clave es palo y un obejto tipo Pokermano con las cartas 
     de ese mismo palo """ 
     d = {}
     for c in self.cartas:
       d.setdefault(c.palo, Pokermano()).agregar_cartas(c)
       """print(c.palo)"""

     """print(d.values())
     print(d.keys())"""
     
     """ se verifica si algun objeto del diccionario tipo Pokermano tiene longitud >5 
     """ 
     
     for manoe in d.values():
         if len(manoe.cartas)< 5:
           continue
         manoe.crear_histo()  
         if manoe.tiene_escalera():
           print ('tiene escalera real')
           return True
     """print ('no tiene escalera real')  """    
     return False

  def clasificar(self):
     """crear lista de clasificaciones de cada mano
     PARA transformar ESTE emtodo y clasifique la mano con la Clasificacion mayo qye tenga la mano
     se puede cambiar la intruccion  Append (que esta almacenando todas las clasificaciones en la lista), por una sustitucion
     para que almacene la ultima clasificacion, ya que sera la ultima que sea True la de mayor puntucion, por que la lista
     nombre_clasificacion esta ordenada de menor a mayor
        """
     self.clasificaciones = [] 
     for etiqueta in Pokermano.nombre_clasificacion:
       f = getattr(self, 'tiene_' + etiqueta)
       if f():
         self.clasificaciones.append(etiqueta) 
     print(self.clasificaciones)

def main():
  carta1 = carta(2,11)
  """print(carta1)"""
  "manon =mano('Nueva mano')"
  "manon.cartas"
  "print(manon.etiqueta)"
  barajau=baraja()
  barajau.barajar()
  "carta2=barajau.quitar_carta()"
  "carta3=barajau.quitar_carta()"
  "manon.agregar_cartas(carta2)"
  "manon.agregar_cartas(carta3) "
  "print(manon)"
  "lmanos=barajau.repartir_manos(2,5)"
  "imprimir_lista(lmanos,2)"
  histoe = {}
  manosa = []
  n=100
  for num in range(n):
    if num % n == 0:
       print(num)
    for i in range(7):
      barajau=baraja()
      barajau.barajar()
      manop=Pokermano()
      barajau.mover_cartas(manop,7)
      manop.ordenar()
      manop.crear_histo()
      print(manop)
      '''print('')
      print(manop.tiene_color())
      print('')
      print(manop.tiene_pareja())
      print('')
      print(manop.tiene_doble_pareja())
      print('')
      print(manop.tiene_trio())
      print('')  
      print(manop.tiene_poker())
      print('')  
      print(manop.tiene_full())
      print('')  
      if (manop.tiene_pareja(2) and manop.tiene_trio(3)):
        print('Tiene Full House')
      print(manop.tiene_escalera())  
      print(manop.tiene_escalera_real()) '''
      manop.clasificar()
      manosa.append(manop)
      for manopp in manosa:
        for etiqueta in manopp.clasificaciones:
          histoe[etiqueta]=histoe.get(etiqueta,0)+1
          

  total=7*n
  print(total,'Total manos generadas')  
  for etiqueta in Pokermano.nombre_clasificacion:
    freq = histoe.get(etiqueta,0)
    if freq == 0:
      continue
    p=total / freq
    print('%s ocurrencias %.2f' % (etiqueta, p))

if __name__ == '__main__':
  main()